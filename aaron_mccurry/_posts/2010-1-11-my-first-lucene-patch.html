--- 
permalink: /blogs/my_first_lucene_patch.html
layout: blogs
title: My First Lucene Patch - Making Lucene Do More With Less
date: 2010-01-11 20:06:21 -05:00
tags: Java Lucene
---
I've been using Lucene for the better part of 2 years, from initial playing around, to prototyping to production application. &nbsp;It's an impressive library and it has come along way in the past couple of years.<div><br /></div><div>When I first started playing around with it the version was 2.1 and the search times were so much faster than what we were trying to use at the time (Oracle Text). &nbsp;The first test was indexing a monster dataset and searching it quickly. &nbsp;It passed with flying colors!</div><div><br /></div><div>Next was to add in record level access control. &nbsp;<a href="http://java.dzone.com/articles/how-implement-row-level-access">Easy</a>&nbsp;and extremely fast.</div><div><br /></div><div>Next was to add in all the other data needed for our application. &nbsp;That was a little bit harder, considering that we have close to 150 fields in our index and well into the billion record range (growing everyday).</div><div><br /></div><div>The problem was that we needed more memory and there was no extra money for any more servers (or upgrades). &nbsp;So there we were, stuck. &nbsp;So I decided to start poking around using <a href="https://visualvm.dev.java.net/">visualvm</a>&nbsp;to see if there were any places in our application or in Lucene to save some memory.</div><div><br /></div><div>We had already disabled norms on all our fields (we really didn't need norms for our data nor did we have the resources). &nbsp;Took a long look at all our fields that we were indexing to see if there were any we didn't need, but we really did need them all. &nbsp;Then I stumbled across the TermInfosReader class in Lucene.</div><div><br /></div><div>This is where Lucene really gets it speed, but also uses quite a bit memory to do it. &nbsp;And this is where I wrote my first Lucene patch.</div><div><br /></div><div>In TermInfosReader there is a bunch stuff but the big memory hogs are in three arrays.</div><div><br /></div><div><ul><li>Terms[]</li><li>TermInfos[]</li><li>long[]</li></ul></div><div>Basically Lucene does a binary search across the Terms array (that by default contains every 128th Term in the index) with a given Term to find where on disk the exact Term needed lives. &nbsp;There's a little bit more going on in the class than that, but that's basically what it's doing.</div><div><br /></div><div>So, I started this patch with the need to save memory. &nbsp;So how in the world do you do that in java when everything is already in basic arrays and everything is needed in memory. &nbsp;Well you have to save it another way, references. &nbsp;References are a hidden cost in Java, every single reference in 32-bit JVM costs you 4 bytes, and 64-bit JVM it's 8 (assuming that you don't have compressed references).</div><div><br /></div><div>Let's count the references.</div><div><br /></div><div><ul><li>Terms[] length * 3, 1 reference for the Term and 2 references for the two Strings inside the Term</li><li>TermInfo[] length * 1</li><li>long[] = 1 reference total<br /></li></ul><div>So, let's talk numbers. &nbsp;If you have a billion terms in your index, that's 125 MB (1,000,000,000 / 128 * (3 + 1 references) * 4 bytes for every ref) bytes of memory for the references. &nbsp;In a 64-bit JVM that doubled 250 MB. &nbsp;Not to mention the object overhead for every one of those Term and TermInfos objects. Wow that's a lot!</div><div><br /></div><div>So I decided to remove nearly all of those references by using a byte array and an int array as an offset index.</div><div><br /></div><div>The results were impressive!</div><div><br /></div><div>Given an index of 6.2 GB size 1,010,000&nbsp;number of documents with 179,822,683 number of terms the default implementation uses 292,235,512 bytes to just get the index usable.</div><div><br /></div><div>My no-ref implementation of the same index uses only 49,849,744 bytes get the index usable. &nbsp;That a 17% of the original size, that's an 83% savings!</div><div><br /></div><div>And the best part is, that it loads the segments faster into memory. &nbsp;So those real-time updates will be online faster. &nbsp;The run-time performance is slightly faster as well. &nbsp;But the huge performance saving is in garbage collection. &nbsp;Over 7 times faster for full GC's on my Macbook Pro. &nbsp;Wow!</div><div><br /></div><div>I think that the results speak for themselves, and I hope that the Lucene folks will accept my patch. &nbsp;That way I won't have to continue patching each version after the fact. &nbsp;Also removing references can be great, but the code required to do it, and maintain the same level of performance, is ugly! &nbsp;So don't try this at home!</div><div><br /></div><div><a href="https://issues.apache.org/jira/browse/LUCENE-2205">LUCENE-2205</a></div><div><br /></div></div> 
