--- 
permalink: /blogs/aaron_mccurry/a_little_tuning_can_go_a_long.html
layout: blogs
title: A little tuning can go a long way...
date: 2009-04-02 21:50:52 -04:00
tags: Java Lucene
---
The application that I'm current developing uses Lucene for searching
and data retrieval.&nbsp; We recently had a rather special need to use one
of the utility classes in Lucene, OpenBitSet.&nbsp; OpenBitSet is not unlike
the regular BitSet provided by the java.util package.&nbsp; The biggest
difference is that the class is NOT final.&nbsp; So for someone like me,
that tinkers and optimizes to get every last bit of performance out of
my application, final classes are a major PITA.<br /><br />The problem:<br /><br />OpenBitSet
provides an optimized "find the next set bit starting here" method
called nextSetBit(long index).&nbsp; However I needed to find the previous
set bit, so naturally I started by using the built-in api.&nbsp; Iterate backwards over each bit starting at given position until a bit that it is set to true is found.&nbsp; Probably not the fastest way, but it
works.&nbsp; I thought that if I wrote my own "find the previous
set bit starting here" method it could be potently a lot faster.&nbsp; And because the class is not final and the internals are not private I can extend it, YAY!<br /><br />So after some work and some tests I came up with this:<br /><br />
<pre class="prettyprint">&nbsp;&nbsp;&nbsp; /**<br />&nbsp;&nbsp;&nbsp; &nbsp;* Finds the previous set bit in the bitset, start looking at the index position.<br />&nbsp;&nbsp;&nbsp; &nbsp;* @param index the index to start looking.<br />&nbsp;&nbsp;&nbsp; &nbsp;* @return the previous position in the bitset that is set.<br />&nbsp;&nbsp;&nbsp; &nbsp;*/<br />&nbsp;&nbsp;&nbsp; public long prevSetBit(long index) {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //get index of the word to start with<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int i = (int) (index &gt;&gt;&gt; 6); //div by 64<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (i &gt;= wlen) {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //if the index requested is greater than the actual<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //max word, just start with the last word<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; i = wlen - 1;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //loop backwards over the bits[] until a non-zero word is found<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; while (i &gt;= 0) {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; long word = bits[i];<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (word != 0) {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //find the position of the most significant bit<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int pomsb = getPositionOfMostSigBit(word);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //multiply by 64<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; long l = ((long) i) &lt;&lt; 6;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //add together to find the actual position<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return l + pomsb;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; i--;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return -1;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; /**<br />&nbsp;&nbsp;&nbsp; &nbsp;* The word passed in, should not be 0.<br />&nbsp;&nbsp;&nbsp; &nbsp;* @param word the word to find the position of the most significant bit.<br />&nbsp;&nbsp;&nbsp; &nbsp;* @return the position in the word.<br />&nbsp;&nbsp;&nbsp; &nbsp;*/<br />&nbsp;&nbsp;&nbsp; private int getPositionOfMostSigBit(long word) {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (word == 1l) {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return 0;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int i = 0;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; while (word != 1) {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; word = word &gt;&gt;&gt; 1;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; i++;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return i;<br />&nbsp;&nbsp;&nbsp; }<br /><br /></pre>
And of course I had to write a performance test to make sure that my work had produced something useful.&nbsp; Here's the test:<br /><br />

<pre class="prettyprint">&nbsp;&nbsp;&nbsp; public static void main(String[] args) {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; CustomOpenBitSet bitSet = new CustomOpenBitSet(Integer.MAX_VALUE);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int maxCount = 1000000;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fillBitSet(bitSet, maxCount);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 10; i++) {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; double s1 = System.nanoTime();<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int slow = runSlowReverseSeeksToSetBits(bitSet, maxCount);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; double e1 = System.nanoTime();<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; double s2 = System.nanoTime();<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int fast = runFastReverseSeeksToSetBits(bitSet, maxCount);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; double e2 = System.nanoTime();<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert (slow == fast);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println("The slow time took " + ((e1-s1) / ONE_BILLION) + " seconds");<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println("The fast time took " + ((e2-s2) / ONE_BILLION) + " seconds");<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; private static int runFastReverseSeeksToSetBits(CustomOpenBitSet bitSet, int maxCount) {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int count = 0;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; long start = Integer.MAX_VALUE;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; while (count &lt; maxCount - 1) {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; long position = bitSet.prevSetBit(start);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; count++;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; start = position - 1;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return count;<br />&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; private static int runSlowReverseSeeksToSetBits(CustomOpenBitSet bitSet, int maxCount) {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int count = 0;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; long start = Integer.MAX_VALUE;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; while (count &lt; maxCount - 1) {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; long position = slowSeek(bitSet,start);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; count++;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; start = position - 1;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return count;<br />&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; private static long slowSeek(CustomOpenBitSet bitSet, long position) {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; while (!bitSet.get(position)) {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; position--;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (position &lt; 0) {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return -1;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return position;<br />&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; private static void fillBitSet(CustomOpenBitSet bitSet, int numberOfBitsToSet) {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Random random = new Random();<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int nextInt = -1;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; numberOfBitsToSet; i++) {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; do {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; nextInt = random.nextInt(Integer.MAX_VALUE);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; } while (bitSet.fastGet(nextInt));<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; bitSet.set(nextInt);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }
</pre>
The
test creates a BitSet that is Integer.MAX_VALUE long and randomly
populates it with 1 million bits set to true.&nbsp; Then starting at
Integer.MAX_VALUE, find all the bits that are set to true, moving from
the greatest position to the smallest position.&nbsp; Do this 10 times and
print off the time taken to perform both algorithms. <br /><br />
<pre class="prettyprint">Pass [0], the slow time took 7.867899136 seconds<br />Pass [0], the fast time took 0.059851008 seconds<br />Pass [1], the slow time took 7.84461184 seconds<br />Pass [1], the fast time took 0.051954944 seconds<br />Pass [2], the slow time took 7.820731904 seconds<br />Pass [2], the fast time took 0.07801088 seconds<br />Pass [3], the slow time took 7.81953408 seconds<br />Pass [3], the fast time took 0.074951168 seconds<br />Pass [4], the slow time took 7.798106112 seconds<br />Pass [4], the fast time took 0.07792384 seconds<br />Pass [5], the slow time took 7.742498048 seconds<br />Pass [5], the fast time took 0.067644928 seconds<br />Pass [6], the slow time took 7.664754944 seconds<br />Pass [6], the fast time took 0.07476992 seconds<br />Pass [7], the slow time took 7.841472768 seconds<br />Pass [7], the fast time took 0.073187072 seconds<br />Pass [8], the slow time took 7.927188992 seconds<br />Pass [8], the fast time took 0.07574912 seconds<br />Pass [9], the slow time took 7.85273088 seconds<br />Pass [9], the fast time took 0.076514048 seconds
</pre>So as you can see the new method is about 100 times faster than just iterating backwards over the bitset, given this sample data.&nbsp; I would assume that if the sample size of 1 million were to increase, the gap between the 2 methods would narrow.<br /> 
