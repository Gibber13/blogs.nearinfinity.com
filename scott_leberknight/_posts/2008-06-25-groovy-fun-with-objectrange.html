---
atom_id: tag:www.nearinfinity.com,2008:/blogs//36.1650 # This is for backwards compatibility do not change!
permalink: /blogs/scott_leberknight/groovy_fun_with_objectrange.html
layout: blogs
title: Groovy Fun With ObjectRange
date: 2008-06-25 15:34:02 -04:00
tags: Groovy JRuby
---
<p>I ran into a situation the other day with Groovy that baffled me at first. Let's create a range  from 0.0 to 10.0 and then use it to check if a certain number is contained within that range, like this:</p>

{% highlight groovy %}
groovy:000> r = 0.0..10.0
===> 0.0..10.0
groovy:000> r.contains(5.6)
===> false
{% endhighlight %}

<p>WTF? The number 5.6 is <i>not</i> contained in the range 0.0 to 10.0? I beg to differ. So what's actually going on here? Using the shell we can do some more digging, interrogating the range object to see what its bounds are, what values it contains if you iterate it, and so on:</p>

{% highlight groovy %}
groovy:000> r = 0.0..10.0
===> 0.0..10.0
groovy:000> r.class
===> class groovy.lang.ObjectRange
groovy:000> r.from.class
===> class java.math.BigDecimal
groovy:000> r.to.class
===> class java.math.BigDecimal
groovy:000> r.each { print " $it " }  
 0.0  1.0  2.0  3.0  4.0  5.0  6.0  7.0  8.0  9.0  10.0 ===> 0.0..10.0
groovy:000> r.contains 5 
===> true
groovy:000> r.contains 5.0
===> true
groovy:000> r.contains 5.6
===> false
{% endhighlight %}

<p>So what did we learn? First, the range is an <code>ObjectRange</code> whose bounds are <code>BigDecimal</code>s. Second, that iterating by default iterates in increments of one. And third that the <code>contains</code> method does not quite do what I would expect by default. Looking at Groovy's <code>ObjectRange</code> class makes it clear exactly what's going on, so let's look:</p>

{% highlight groovy %}
public boolean contains(Object value) {
  Iterator it = iterator();
  if (value == null) return false;
  while (it.hasNext()) {
    try {
      if (DefaultTypeTransformation.compareEqual(value, it.next())) return true;
    } catch (ClassCastException e) {
      return false;
    }
  }
  return false;
}
{% endhighlight %}

<p>The Groovy <code>ObjectRange</code>'s <code>contains</code> method defines containment as whether a value is contained within the values <i>generated by its iterator</i>. By now many of my <b>many millions</b> of readers are about to post a comment telling me the problem, so I'll preempt that temptation by adding a few more lines of interaction with the Groovy shell:</p>

{% highlight groovy %}
groovy:000> r.containsWithinBounds 5.0
===> true
groovy:000> r.containsWithinBounds 5.6
===> true
{% endhighlight %}

<p>Aha! So <code>contains</code> doesn't do what you might think it should, but <code>containsWithinBounds</code> does. Its JavaDoc says "Checks whether a value is between the from and to values of a Range." Conspicuously there is no JavaDoc on the <code>contains</code> method to tell me that what it actually does is check whether a value is contained within the <i>discrete values</i> generated by the iterator. Let's try more more thing:</p>

{% highlight groovy %}
groovy:000> r.containsWithinBounds 5
ERROR java.lang.ClassCastException: java.lang.Integer
        at groovysh_evaluate.run (groovysh_evaluate:2)
        ...
{% endhighlight %}

<p>Oops! Not only do you need to call <code>containsWithinBounds</code> rather than <code>contains</code>, you also need to call it with the correct type, as there is no coercion going on since it uses <code>Comparable.compareTo()</code> under the covers.</p>

<p>Notwithstanding all the recent activity regarding all the <a href="http://www.ruby-forum.com/topic/157034">Ruby security flaws</a> recently discovered, how does Ruby handle inclusion of a number within a range? Here's some irb output:</p>

{% highlight ruby %}
>> r = 0.0..10.0
=> 0.0..10.0
>> r.class
=> Range
>> r.begin.class
=> Float
>> r.end.class
=> Float
>> r.each { |item| print " #{item} " }
TypeError: can't iterate from Float
        from (irb):53:in `each'
        from (irb):53
>> r.include? 5
=> true
>> r.include? 5.0
=> true
>> r.include? 5.6
=> true
{% endhighlight %}

<p>To me this is more <i>semantically</i> and <i>intuitively</i> correct behavior. First, while I can create a range with float bounds, I cannot iterate that range - for <i>non-integral</i> numbers, how exactly can you define the next item after 0.0 for example? 0.1, 0.01, 0.001, and so on till infinity. Second, the <code>include?</code> method behaves as I would expect no matter what type of argument I pass. I am able to iterate ranges of integral numbers, however, which could arguably also be confusing since the behavior of the method depends on the type. Then again, that's pretty much what polymorphic method behavior is about I suppose.</p>

{% highlight ruby %}
>> r = 0..10
=> 0..10
>> r.each { |item| print " #{item} " }
 0  1  2  3  4  5  6  7  8  9  10 => 0..10
{% endhighlight %}

<p>In the case of integers Ruby uses an increment of one by default. You could use the <code>step</code> method to get a different increment, e.g.:</p>

{% highlight ruby %}
>> r.step(2) { |item| print " #{item} " }
 0  2  4  6  8  10 => 0..10
{% endhighlight %}

<p>So what's the point of all this? That Ruby is better than Groovy? Nope. I really like both languages. I think there are a couple of points that were reinforced to me:</p>

<p>First, RTFM (or source code --> RTFC). Even though Groovy's <code>contains</code> method doesn't behave how <i>I</i> think it should, there is the method I was looking for with <code>containsWithinBounds</code>.</p>

<p>Second, having a shell to play around with short snippets of code is really, really useful, without needing to create a class with a main method just to play around with code.</p>

<p>Third, documentation and semantics matter. If something doesn't feel intuitively correct based on how similar things act, it is more likely to cause confusion and errors. In this case, since my unit test immediately caught the error, I was able to figure the problem out in a few minutes.</p>

<p>Finally, following on from the last point, unit tests continue to remain valuable. Of course anyone who knows me would roll their eyes over my anal-ness (which Mac's dictionary is telling me is not really a word but I don't care at the moment) expecting me to get something about unit testing in somehow.</p> 
