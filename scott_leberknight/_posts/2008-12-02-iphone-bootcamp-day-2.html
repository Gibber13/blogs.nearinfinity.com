---
permalink: /blogs/scott_leberknight/iphone_bootcamp_day_2.html
layout: blogs
title: !binary |-
  aVBob25lIEJvb3RjYW1wIERheSAy
date: 2008-12-02 23:37:00.000000000 -05:00
tags: iphone macosx
---
{% raw %}
 <p>Today is Day 2 of the iPhone bootcamp at <a href="http://www.bignerdranch.com/">Big Nerd Ranch</a>.</p>

<p>See <a href="/blogs/scott_leberknight/iphone_bootcamp_blogs.html">here</a> for a list of each day's blog entries.</p>

<h3>Localization</h3>

<p>After a nice french toast breakfast, we headed down to the classroom and started off learning about localizing iPhone apps. As with Cocoa, you basically have string tables, localized resources (e.g. images), and a <i>separate</i> XIB file for <i>each</i> different locale you are supporting. (Interface Builder stores the UI layout in an XML format in a XIB file, e.g. MainWindow.xib.) This means that, unlike Java Swing for example, you literally define a separate UI for each locale. We localized our DistanceTracker application that we built on day one for English and German locales. To start you use the <code>genstrings</code> command line utility to generate a localizable string resource and then in Xcode make it localizable; this creates separate string tables for each language which a translator can then edit and do the actual translation. You also need to make the XIB files localized and then redo the UI layout for each locale. Sometimes this might not be too bad, but if the locale uses, for example, a right-to-left language then you'd need to reverse the position of all the UI controls. While having to create essentially a separate UI for each locale seems a bit onerous, it makes a certain amount of sense in that for certain locales the UI might be laid out completely differently, e.g. think about the right-to-left language example. Finally, you use <code>NsLocalizedString</code> in code, which takes a string key and a comment intended for the translator which is put into the string tables for each locale - at runtime the value corresponding to the specified key is looked up based on the user's locale and is displayed. If a value isn't found, the key is displayed as-is which might be useful if you have a situation where all locales use the same string or something like that.</p>

<h3>View Controllers</h3>

<p>After localization we tackled view controllers. View controllers control a single view, and are used with <code>UITabBarController</code> and <code>UINavigationController</code>. We created a "navigation-based application" which sets up an application containing a <code>UINavigationController</code>. The difference between <code>UITabBarController</code> and <code>UINavigationController</code> is that the tab bar controller stores its views in a list and allows the user to toggle back and forth between views. For example, the "Phone" application on the iPhone has a tab bar at the bottom (which is where it is displayed in apps) containing Favorites, Recents, Contacts, Keypad, and Voicemail tab bar items. Tab bar items are always visible no matter what view is currently visible. As you click the tab bar items, the view switches. So, a <code>UITabBarController</code> is a controller for switching between views in a "horizontal" manner somewhat similar to the cover flow view in Finder. On the other hand you use <code>UINavigationController</code> for stack-based "vertical" navigation through a series of views. For example, the "Contacts" iPhone application lists your contacts; when you touch a contact, a detail view is pushed onto the <code>UINavigationController</code> stack and becomes the visible and "top" view. You can of course create applications that combine these two types of view controllers. In class we created a "To Do List" application having a tab bar with "To Do List" and "Date & Time" tabs. If you touch "To Do List" you are taken to a list of To Do items. Touching one of the To Do items pushes the To Do detail view onto the stack, which allows you to edit the item. Touching "Date & Time" on the tab bar displays the current date and time in a new view.</p>

<p>It took me a while to get my head wrapped around combining the different types of view controllers in the same application and how to connect everything together. Since I am used to web app development, this style of development requires a different way of thinking. I actually like it better since it has a better separation of concerns and is more true to the MVC pattern than web applications are, but I'm sure I'll have to try to build more apps using the various view controllers to get more comfortable.</p>

<h3>Table Views</h3>

<p>We had a good lunch and after that headed back down to cover table views. Table views are views that contain cells. Each cell contains some data that is loaded from some data source. For example, the "Contacts" application uses a <code>UITableView</code> to display all your contacts. The "To Do List" application we created earlier also uses a <code>UITableView</code> to list the To Do items. Basically, <code>UITableView</code> presents data in a list style.</p>

<p>Table views must have some data source, such as an array, a SQLite database, or a web service. You are responsible for implementing data retrieval methods so that when the table view asks for the contents of a specific cell, you need to offer up a cell containing the data appropriate for the row index. Since the iPhone has limited real estate, <code>UITableView</code> re-uses cells that have been moved off screen, for example if they are scrolled out of view. This way, rather than create new cells every single time <code>UITableView</code> asks for a cell, you instead ask if there are any cells that can be re-used. If so, you populate the cell with new data and return it.</p>

<p><code>UITableView</code> also provides some basic functionality, like the ability to drag cells, delete them, etc. You only need to implement the logic needed when events, like move or delete, occur. Another thing you typically do with table views is respond when a user touches a cell. For example, in the "To Do List" application a new "detail" view is displayed when you touch a cell in the table view. This is probably the most common usage; table views display aggregate or summary data, and you can implement "drill down" logic when a user touches a cell. For example, when a user touches a To Do item cell, a new view controller is pushed onto the stack of a <code>UINavigationController</code> showing the "detail" view and allowing you to edit the To Do item. Another cool thing you can do with table views is to subclass <code>UITableView</code> in order to lay out <i>subviews</i> in each cell. In the "To Do List" app, we added subviews to each cell to show the To Do item title, part of the longer item description in smaller font, and an image to the left of the title if the item was designated as a "permanent" item. The "Photo Albums" iPhone application also uses subviews; it shows an image representing the album and the album title in each cell.</p>

<h3>Saving and Loading Data Using SQLite</h3>

<p>By this time, it was already late afternoon, and we hiked out to the old paper mill and back. It stared getting colder on the way back as the sun started to set. When we got back, we learned all about saving and loading data using SQLite. First, we learned about the "Application Sandbox" which can only be read/written by your application, for security reasons. There are several locations that each iPhone application can store data. Within you application's bundle (e.g. &lt;AppName.app&gt;) there is Documents, Library/Preferences, Library/Caches, and tmp folders. Documents contains persistent data, such as a SQLite database, that gets backed up when you sync your iPhone. Library/Preferences contains application preference data that gets backed up when you sync. Library/Caches, which Joe and Brian (the other instructor who is helping Joe this week) just found out about before our hike, is new in version 2.2 of the iPhone software, and stores data cached between launches of your application. The tmp directory is, as you expect, used for temporary files. You as the developer are responsible for cleaning up your mess in the tmp folder, however!</p>

<p>After discussing the sandbox restrictions, we learned how you can locate the Documents directory using the <code>NSSearchPathForDirectoriesInDomains</code> function. Finally, we learned how to use SQLite to add persistence to iPhone applications using SQLite, which I continually misspell with two "L"s even though there is really only one! SQLite supports basic SQL commands like select, insert, update, and delete. The reason you need to know how to find the Documents directory is because you'll need to create a copy of a default SQLite database you ship with your application into Documents. Basically, you supply an empty database with your application's Resources &mdash; this is read-only to your app. In order to actually write new data, the database must reside in a location (such as Documents) where you have access to write. So, the first thing to do is copy the default database from Resources to the Documents directory where you can then read and write, and where the database will then automatically be backed up when the user syncs her iPhone.</p>

<p>We then added SQLite persistence to the "To Do List" application. While I think SQLite is cool in theory, actually using it to query, insert, update, and delete data is painful, as you have to handle all the details of connecting, writing and issuing basic CRUD queries, stepping through the results, closing the statements, cleaning up resources, etc. It feels like writing raw JDBC code in Java but possibly worse, if that's possible. Someone told me tonight there is supposedly some object-relational mapping library which makes working with SQLite more palatable, though I don't remember what it was called or if it is even an object-relational mapper in the same sense as say, Hibernate. Regardless, I persisted (ha, ha) and got my "To Do List" application persisting data via SQLite.</p>

<h3>WebKit</h3>

<p>Joe apparently gave a short lecture on using WebKit in iPhone applications at this point. Unfortunately I decided to go for a run and missed the lecture. In any case, WebKit is the open source rendering engine used in Safari (both desktop and mobile versions) to display web content. You use <code>UIWebView</code> in your application and get all kinds of functionality out-of-the-box for hardly any work at all. <code>UIWebView</code> takes care of all the rendering stuff including HTML, CSS, and JavaScript. You can also hook into events, such as when the web view started and finished loading, via the <code>UIWebViewDelegate</code> protocol. In our lab exercises after dinner, we implemented a simple web browser using <code>UIWebView</code> and used an activity progress indicator to indicate when a page is loading.</p>

<p>In addition to loading HMTL content in <code>UIWebView</code>, you can also load things like images and audio content. It is ridiculously easy to add a <code>UIWebView</code> to your application in order to display web content.</p>

<h3>Random Thoughts</h3>

<p>Another long day has come and gone. It is amazing how much energy everyone has to basically learn all day and keep going well into the night hours.</p>

<p>Today we learned about localization on the iPhone. The most important thing is that you need to create a separate UI for each locale you are supporting. This means you should not work on localizing until right before you are ready to ship; otherwise you'll spend all your time continually tweaking all the localized UI after every little change you make.</p>

<p>Tab and navigation view controllers are powerful ways to implement application navigation using a tab paradigm or a stack-based, guided navigation scheme, respectively. Combined with table views, you can accomplish a lot with just these three things.</p>

<p>While I think having a relational database available for persistence in your iPhone apps is nice, I really do not want to write the low-level code required to interact with SQLite; once you get used to using an ORM tool like Hibernate or ActiveRecord you really don't want to go back to hand-writing basic CRUD statements, marshaling result sets into objects and vice-versa, and managing database resource manually. Guess I'll need to check into that SQLite library someone mentioned.</p>

<p>It is surprisingly easy to integrate web content directly into an iPhone application using <code>UIWebView</code>!</p>

<p>Tomorrow looks to be really cool, covering things like media and OpenGL. Until then, ciao!</p> 
{% endraw %}
