--- 
permalink: /blogs/deferred_execution_the_elegance_of.html
layout: blogs
title: Deferred Execution, the Elegance of LINQ
date: 2008-02-20 09:45:58 -05:00
tags: .NET
---
<p>One of the things I love about LINQ is its deferred execution model. It's the type of thing that makes sense academically when you first read about it (e.g. in <a href="http://weblogs.asp.net/scottgu/archive/2007/06/29/linq-to-sql-part-3-querying-our-database.aspx">Part Three</a> of Scott Gunthrie's LINQ to SQL series), but for me anyway, it took some time to understand enough to use effectively.</p>
<div style="FLOAT: right; MARGIN-LEFT: 10px">
<script type="text/javascript">
        var currentPageUrl = 'http://rapidapplicationdevelopment.blogspot.com/2008/02/deferred-execution-elegance-of-linq.html';

        /* Digg */
        var diggIframe = document.createElement('iframe');
        diggIframe.setAttribute('src', 'http://digg.com/tools/diggthis.php?u=' + currentPageUrl);
        diggIframe.setAttribute('height', '80');
        diggIframe.setAttribute('width', '52');
        diggIframe.setAttribute('frameborder', '0');
        diggIframe.setAttribute('scrolling', 'no');
        diggIframe.setAttribute('style', 'margin-left:auto; margin-right:auto; display:block; text-align:center;');

        /* DotNetKicks */
        var dotnetkicksLink = document.createElement('a');
        dotnetkicksLink.setAttribute('href', 'http://www.dotnetkicks.com/kick/?url=' + currentPageUrl);
        var dotnetkicksImg = document.createElement('img');
        dotnetkicksImg.setAttribute('src', 'http://www.dotnetkicks.com/Services/Images/KickItImageGenerator.ashx?url=' + currentPageUrl);
        dotnetkicksImg.setAttribute('alt', 'Kick this article (a good thing) on DotNetKicks');
        dotnetkicksImg.setAttribute('border', '0');
        dotnetkicksImg.setAttribute('style', 'margin-left:auto; margin-right:auto; display:block; text-align:center;');
        dotnetkicksLink.appendChild(dotnetkicksImg);

        var div = document.createElement('div');
        div.appendChild(diggIframe);
        div.appendChild(document.createElement('br'));
        div.appendChild(dotnetkicksLink);

        document.write(div.innerHTML);
    </script>
</div>
<p>For instance the <a href="http://rapidapplicationdevelopment.blogspot.com/2008/02/daily-rss-download.html">Daily RSS Download</a> open source application that I wrote about last week needs to download entries (posts) that are newly published since the last download. While it isn't a complicated problem, my first attempt at a solution didn't use the power of LINQ correctly. I'll explain my naâ€¢ve solution in this post, describe how LINQ's deferred execution works (i.e. Lambda expressions), explain the problems with my solution, then give an the elegant solution that is only possible because of LINQ's deferred execution model. See if you can spot my error along the way.</p>
<p><b>Downloading the Latest Entries</b></p>
<p>Downloading the latest entries would be a ridiculously simple problem if there weren't multiple formats for RSS. But since the solution needs to support Atom and RSS 2.0 and 1.0 and potentially other future formats, the class structure should be set up appropriately:</p>
<p><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://bp3.blogger.com/_gez10dNhuPk/R7wv8TOwvgI/AAAAAAAAAog/ValJzmKGsRg/s1600-h/01-ClassDiagram.jpg"><img id="BLOGGER_PHOTO_ID_5169059185315331586" style="CURSOR: hand" alt="" src="http://bp3.blogger.com/_gez10dNhuPk/R7wv8TOwvgI/AAAAAAAAAog/ValJzmKGsRg/s400/01-ClassDiagram.jpg" border="0" /></a></p>
<p>The newspaper class primarily exists to enumerate feeds:</p>
<p><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">public</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes"> <span style="COLOR: blue">class</span> <span style="COLOR: #2b91af">Newspaper</span> {<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">public</span> <span style="COLOR: blue">void</span> DownloadNow() {<span style="COLOR: blue"><br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>foreach</span> (<span style="COLOR: #2b91af">Feed</span> objFeed <span style="COLOR: blue">in</span> Settings.Feeds) {<br /><span style="mso-spacerun: yes">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>objFeed.DownloadRecentEntries(...);<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>}<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>}<br />}</span></p>
<p>The Feed class is abstract and during runtime is either an RssFeed or an AtomFeed. The relevant function Feed.DownloadRecentEntries() calls the abstract Feed.GetEntries() method, which returns a group of Entry objects. </p>
<p><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">public</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes"> <span style="COLOR: blue">abstract</span> <span style="COLOR: blue">class</span> <span style="COLOR: #2b91af">Feed</span> {<span style="COLOR: blue"><br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>public</span> <span style="COLOR: blue">abstract</span> <span style="COLOR: #2b91af">IEnumerable</span>&lt;<span style="COLOR: #2b91af">Entry</span>&gt; GetEntries(<span style="COLOR: #2b91af">XDocument</span> rssfeed);<span style="COLOR: blue"><br /><br /><span style="mso-spacerun: yes">&nbsp; &nbsp;&nbsp;</span>public</span> <span style="COLOR: blue">void</span> DownloadRecentEntries(<span style="COLOR: blue">...</span>) {<br /><span style="COLOR: #2b91af"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;</span>XDocument</span> xdocFeed = <span style="COLOR: #2b91af">XDocument</span>.Load(Url);<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;</span><span style="COLOR: #2b91af">IEnumerable</span>&lt;<span style="COLOR: #2b91af">Entry</span>&gt; lstRecentPosts = GetEntries(xdocFeed);<br /><br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;</span><span style="COLOR: blue">foreach</span> (<span style="COLOR: #2b91af">Entry</span> objEntry <span style="COLOR: blue">in</span> lstRecentPosts) {<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;</span>objEntry.Download(...)<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;</span>}<br /><span style="mso-spacerun: yes">&nbsp; &nbsp;&nbsp;</span>}<br />}<br style="mso-special-character: line-break" /><br style="mso-special-character: line-break" /></span></p>
<p>The Feed classes, RssFeed and AtomFeed then implement GetEntries as follows:</p>
<p><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">publpublic</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes"> <span style="COLOR: blue">class</span> <span style="COLOR: #2b91af">RssFeed</span> : <span style="COLOR: #2b91af">Feed</span> {<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">public</span> <span style="COLOR: blue">override</span> <span style="COLOR: #2b91af">IEnumerable</span>&lt;<span style="COLOR: #2b91af">Entry</span>&gt; GetEntries(<span style="COLOR: #2b91af">XDocument</span> rssfeed) {<br /><span style="COLOR: blue"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>return</span> <span style="COLOR: blue">from</span> item <span style="COLOR: blue">in</span> rssfeed.Descendants(<span style="COLOR: #a31515">"item"</span>)<br /><span style="COLOR: blue"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>where</span> (DateParser.ParseDateTime(item.Element(<span style="COLOR: #a31515">"pubDate"</span>).Value) <br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>&gt;= <span style="COLOR: blue">this</span>.LastDownloaded) <br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>|| <span style="COLOR: blue">this</span>.LastDownloaded == <span style="COLOR: blue">null<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>select</span> (<span style="COLOR: #2b91af">Entry</span>)<span style="COLOR: blue">new</span> <span style="COLOR: #2b91af">RssEntry</span>(item, <span style="COLOR: blue">this</span>);<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>}<br />}<br /><br /><span style="COLOR: blue">public</span> <span style="COLOR: blue">class</span> <span style="COLOR: #2b91af">AtomFeed</span> : <span style="COLOR: #2b91af">Feed</span> {<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">public</span> <span style="COLOR: blue">override</span> <span style="COLOR: #2b91af">IEnumerable</span>&lt;<span style="COLOR: #2b91af">Entry</span>&gt; GetEntries(<span style="COLOR: #2b91af">XDocument</span> rssfeed) {<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">return</span> <span style="COLOR: blue">from</span> item <span style="COLOR: blue">in</span> rssfeed.Descendants(_atomNamespace + <span style="COLOR: #a31515">"entry"</span>)<br /><span style="COLOR: blue"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>where</span> (DateParser.ParseDateTime(<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>item.Element(_atomNamespace + <span style="COLOR: #a31515">"published"</span>).Value) <br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>&gt;= <span style="COLOR: blue">this</span>.LastDownloaded) <br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>|| <span style="COLOR: blue">this</span>.LastDownloaded == <span style="COLOR: blue">null</span><br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">select</span> (<span style="COLOR: #2b91af">Entry</span>)<span style="COLOR: blue">new</span> <span style="COLOR: #2b91af">AtomEntry</span>(item, <span style="COLOR: blue">this</span>);<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>}<br />}</span></p>
<p>Yes, that's all LINQ to XML in there. It looks a lot like SQL, but as you'll see in a second it's really just glorified syntactic sugar. Expressive though, isn't it? While the astute reader may have already spotted the inelegance of my solution, for those unfamiliar with LINQ, let's first describe what AtomFeed.GetEntries() does.</p>
<p><b>What is this Deferred Execution Stuff?</b></p>
<p>If you already understand LINQ and how delayed execution works feel free to skip this section. For everyone else it's important to understand that the following line:</p>
<p><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">from</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes"> item <span style="COLOR: blue">in</span> rssfeed.Descendants(<span style="COLOR: #a31515">"item"</span>)<br /><span style="COLOR: blue"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>where</span> (DateParser.ParseDateTime(item.Element(<span style="COLOR: #a31515">"pubDate"</span>).Value) <br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>&gt;= <span style="COLOR: blue">this</span>.LastDownloaded) <br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>|| <span style="COLOR: blue">this</span>.LastDownloaded == <span style="COLOR: blue">null<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>select</span> (<span style="COLOR: #2b91af">Entry</span>)<span style="COLOR: blue">new</span> <span style="COLOR: #2b91af">RssEntry</span>(item, <span style="COLOR: blue">this</span>);</span></p>
<p>Is actually just syntactic sugar for the following set of statements:</p>
<p><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">rssfeed<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span><b style="mso-bidi-font-weight: normal">.Descendants</b>(_atomNamespace + <span style="COLOR: #a31515">"entry"</span>)<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span><b style="mso-bidi-font-weight: normal">.Where</b>( item =&gt; (<span style="COLOR: #2b91af">DateParser</span>.ParseDateTime(<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>item.Element(_atomNamespace + <span style="COLOR: #a31515">"published"</span>).Value) <br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>&gt;= <span style="COLOR: blue">this</span>.LastDownloaded) <br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>|| <span style="COLOR: blue">this</span>.LastDownloaded == <span style="COLOR: blue">null</span>)<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span><b style="mso-bidi-font-weight: normal">.Select</b>( item =&gt; (<span style="COLOR: #2b91af">Entry</span>)<span style="COLOR: blue">new</span> <span style="COLOR: #2b91af">AtomEntry</span>(item, <span style="COLOR: blue">this</span>));</span></p>
<p>Now XDocument.Descendants() returns IEnumerable<xelement> which most definitely does not have a Where() function on it. And if you look at the return type of Where() <i>in this context</i>, it returns an IEnumerable<xelement> which definetly does not have a Select() method on it. That's because Where() and Select() are <a href="http://weblogs.asp.net/scottgu/archive/2007/03/13/new-orcas-language-feature-extension-methods.aspx">extension methods</a>, meaning you can attach them on to just about anything. They're new to C# 3.0 and are beyond the scope of this article.</p>
<p>But more important for the topic of deferred execution is the =&gt; operator, which is a <a href="http://weblogs.asp.net/scottgu/archive/2007/04/08/new-orcas-language-feature-lambda-expressions.aspx">Lambda expression</a> and is also new to C# 3.0. The best way to understand them is that they are <i>essentially</i> syntactic sugar for an <a href="http://msdn2.microsoft.com/en-us/library/0yw3tz5k(VS.80).aspx">anonymous method</a> (e. (e.g. a type safe function pointer to code). So we could again rewrite our code as follows:</p>
<p><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">rssfeed<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>.Descendants(_atomNamespace + <span style="COLOR: #a31515">"entry"</span>)<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>.Where(<b style="mso-bidi-font-weight: normal"><span style="COLOR: blue">delegate</span>(<span style="COLOR: #2b91af">XElement</span> item) { <br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">return</span> (<span style="COLOR: #2b91af">DateParser</span>.ParseDateTime(<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>item.Element(_atomNamespace + <span style="COLOR: #a31515">"published"</span>).Value) <br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>&gt;= <span style="COLOR: blue">this</span>.LastDownloaded) || <span style="COLOR: blue">this</span>.LastDownloaded == <span style="COLOR: blue">null</span>; }</b>)<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>.Select(<b style="mso-bidi-font-weight: normal"><span style="COLOR: blue">delegate</span>(<span style="COLOR: #2b91af">XElement</span> item) { <br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">return</span> (<span style="COLOR: #2b91af">Entry</span>)<span style="COLOR: blue">new</span> <span style="COLOR: #2b91af">AtomEntry</span>(item, <span style="COLOR: blue">this</span>); }</b>);</span></p>
<p>Back in familiar territory yet? If not you probably aren't familiar with C# 2.0. In the background the compiler takes the anonymous methods above and turns them into methods on the current class and instantiates new delegates of the correct type that points to them and passes them to the Select() and Where() methods. 
<p>The The key thing to note is that the arguments for select and where are delegates, and so when those delegates are executed is beyond our control. In fact if you put a Console.WriteLine or a breakpoint inside of the AtomEntry constructor, it won't get called until the resulting IEnumerable is enumerated, specifically the following line in the first code sample:</p>
<p><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">foreach</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes"> (<span style="COLOR: #2b91af">Entry</span> objEntry <span style="COLOR: blue">in</span> lstRecentPosts) {</span></p>
<p>So that's delayed execution. But understanding how it works and how to use it are completely different things.</p>
<p><b>The Inelegant Solution</b></p>
<p>Getting back to my code sample you may have picked up that my where clause is the mistake. I implemented it like this because RSS and Atom have different field names for the published date. But the way I wrote it I'd have to make two changes if I wanted to change which entries to download. Ok, big deal, I'm extremely unlikely to make changes to that where clause right? Or I wasn't until I wanted functionality to set some defaults based on the average length of posts prior to downloading posts. Basically:</p>
<p><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">public</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes"> <span style="COLOR: blue">static</span> Feed CreateFeed(<span style="COLOR: blue">string</span> strUrl, <span style="COLOR: blue">int</span> intDisplayOrder) {<br /><span style="COLOR: #2b91af"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>IEnumerable</span>&lt;Entry&gt; lstRecentEntries = feed.GetEntries(rssfeed);<br /><span style="COLOR: blue"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>double</span> intAveragePostSize = lstRecentEntries.Average(<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>i =&gt; i.Description.Length);<br /><span style="COLOR: green"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>// if the feeds posts are typically small then include the <br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>// description field in the summary and download the content <br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>// for the main article from the link<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span></span><span style="COLOR: blue">if</span> (intAveragePostSize &lt; 1000) {<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>...<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>} else {<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>...<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>}<br />}</span></p>
<p>Except this now ties me to the were clause, when what I'd really like to do is just get the average post size for the last couple of posts. The problem is that GetEntries() isn't generic enough.</p>
<p><b>The Elegant Solution</b></p>
<p>The The solution is then to normalize out (excuse the database terminology) the where clause into the two methods that use GetEntries(). So GetEntries() becomes simple:</p>
<p><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">public</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes"> <span style="COLOR: blue">override</span> <span style="COLOR: #2b91af">IEnumerable</span>&lt;<span style="COLOR: #2b91af">Entry</span>&gt; GetEntries(<span style="COLOR: #2b91af">XDocument</span> rssfeed) {<br /><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">return</span> <span style="COLOR: blue">from</span> item <span style="COLOR: blue">in</span> rssfeed.Descendants(_atomNamespace + <span style="COLOR: #a31515">"entry"</span>)<br /><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="mso-spacerun: yes">&nbsp;&nbsp; </span><span style="COLOR: blue">select</span> (<span style="COLOR: #2b91af">Entry</span>)<span style="COLOR: blue">new</span> <span style="COLOR: #2b91af">AtomEntry</span>(item, <span style="COLOR: blue">this</span>);<br />}</span></p>
<p>And then Feed.CreateFeed() and Feed.DownloadRecentEntries() become more complicated</p>
<p><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">public</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes"> <span style="COLOR: blue">abstract</span> <span style="COLOR: blue">class</span> <span style="COLOR: #2b91af">Feed</span> {<span style="COLOR: blue"><br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>public</span> <span style="COLOR: blue">abstract</span> <span style="COLOR: #2b91af">IEnumerable</span>&lt;<span style="COLOR: #2b91af">Entry</span>&gt; GetEntries(<span style="COLOR: #2b91af">XDocument</span> rssfeed);<span style="COLOR: blue"><br /><br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>public</span> <span style="COLOR: blue">static</span> Feed CreateFeed(<span style="COLOR: blue">string</span> strUrl, <span style="COLOR: blue">int</span> intDisplayOrder) {<br /><span style="COLOR: blue"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span></span><span style="COLOR: #2b91af"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;</span>IEnumerable</span>&lt;<span style="COLOR: #2b91af">Entry</span>&gt; lstEntries = feed.GetEntries(rssfeed);<br /><span style="COLOR: blue"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;</span></span><b style="mso-bidi-font-weight: normal"><span style="COLOR: green">// get the five most recent posts<br /></span><span style="COLOR: #2b91af"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>IEnumerable</span>&lt;<span style="COLOR: #2b91af">Entry</span>&gt; lstRecentEntries = <br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">from</span> entry <span style="COLOR: blue">in</span> lstEntries.Take(5)<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">select</span> entry;</b><span style="COLOR: blue"><br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>double</span> intAveragePostSize = lstRecentEntries.Average(<br /><span style="COLOR: blue"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span></span><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>i =&gt; i.Description.Length);<br /><span style="COLOR: blue"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span></span><span style="COLOR: green"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;</span></span><span style="COLOR: blue">if</span> (intAveragePostSize &lt; 1000) {<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;</span></span><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;</span>...<br /><span style="COLOR: blue"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span></span><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;</span>} else {<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;</span></span><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;</span>...<br /><span style="COLOR: blue"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span></span><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>}<span style="COLOR: blue"><br /><br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>public</span> <span style="COLOR: blue">void</span> DownloadRecentEntries(<span style="COLOR: blue">...</span>) {<br /><span style="COLOR: #2b91af"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>XDocument</span> xdocFeed = <span style="COLOR: #2b91af">XDocument</span>.Load(Url);<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: #2b91af">IEnumerable</span>&lt;<span style="COLOR: #2b91af">Entry</span>&gt; lstEntries = GetEntries(xdocFeed);<br /><span style="COLOR: blue"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;</span></span><b style="mso-bidi-font-weight: normal"><span style="COLOR: green">// get newly published posts<br /></span></b><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><b style="mso-bidi-font-weight: normal"><span style="COLOR: #2b91af">IEnumerable</span>&lt;<span style="COLOR: #2b91af">Entry</span>&gt; lstRecentPosts = <span style="COLOR: blue">from</span> entry <span style="COLOR: blue">in</span> lstEntries<br /><span style="COLOR: blue"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="COLOR: blue">where</span> (entry.Published &gt;= <span style="COLOR: blue">this</span>.LastDownloaded) <br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>|| <span style="COLOR: blue">this</span>.LastDownloaded == <span style="COLOR: blue">null<br /></span><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>select</span> entry;</b><br /><br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">foreach</span> (<span style="COLOR: #2b91af">Entry</span> objEntry <span style="COLOR: blue">in</span> lstRecentPosts) {<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>objEntry.Download(...)<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>}<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>}<br />}</span></p>
<p>Note that we now have a second LINQ statement that runs against the results of the LINQ statement in GetEntries(). But since nothing's been executed yet we're just building out the statement that we will eventually run when the resulting IEnumerable if enumerated. So we've now spread our LINQ statements across an inheriting and a base class, and in process we've made GetEntries() extremely generic.</p>
<p><b>Conclusion</b></p>
<p>So what's the big deal? The big deal is that we can spread our data access statements across multple classes and because of deferred execution we don't need to worry about the performance of generic methods that are closer to the data that don't contain a "where" clause. This may not be a huge deal in this example, but it becomes extremely powerful when the user interface tier can tack on "order by" statements or "filters" BEFORE anything is executed against your data store. And that, for me, is at the heart of the beauty of LINQ.</p> 
