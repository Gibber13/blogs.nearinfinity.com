--- 
permalink: /blogs/lee_richardson/expression_trees_why_linq_to.html
layout: blogs
title: "Expression Trees: Why LINQ to SQL is Better than NHibernate"
date: 2008-03-27 16:59:40 -04:00
tags: .NET
---
{% raw %}
<p>In my last post I described how the <a href="http://rapidapplicationdevelopment.blogspot.com/2008/03/how-systemlinqwhere-really-works.html">Where()</a> function works for LINQ to Objects via extension methods and the yield statement. That was interesting. But where things get crazy is how the other LINQ technologies, like LINQ to SQL use extension methods. In particular it's their use of a new C# 3 feature called expression trees that makes them extremely powerful. And it's an advantage that more traditional technologies like NHibernate will never touch until they branch out from being a simple port of a Java technology. In this post I'll explain the inherent advantage conferred on LINQ technologies by expression trees and attempt to describe how the magic works.</p>
<div style="FLOAT: right; MARGIN-LEFT: 10px">
<script type="text/javascript">
        var currentPageUrl = 'http://rapidapplicationdevelopment.blogspot.com/2008/03/expression-trees-why-linq-to-sql-is.html';

        /* Digg */
        var diggIframe = document.createElement('iframe');
        diggIframe.setAttribute('src', 'http://digg.com/tools/diggthis.php?u=' + currentPageUrl);
        diggIframe.setAttribute('height', '80');
        diggIframe.setAttribute('width', '52');
        diggIframe.setAttribute('frameborder', '0');
        diggIframe.setAttribute('scrolling', 'no');
        diggIframe.setAttribute('style', 'margin-left:auto; margin-right:auto; display:block; text-align:center;');

        /* DotNetKicks */
        var dotnetkicksLink = document.createElement('a');
        dotnetkicksLink.setAttribute('href', 'http://www.dotnetkicks.com/kick/?url=' + currentPageUrl);
        var dotnetkicksImg = document.createElement('img');
        dotnetkicksImg.setAttribute('src', 'http://www.dotnetkicks.com/Services/Images/KickItImageGenerator.ashx?url=' + currentPageUrl);
        dotnetkicksImg.setAttribute('alt', 'Kick this article (a good thing) on DotNetKicks');
        dotnetkicksImg.setAttribute('border', '0');
        dotnetkicksImg.setAttribute('style', 'margin-left:auto; margin-right:auto; display:block; text-align:center;');
        dotnetkicksLink.appendChild(dotnetkicksImg);

        /* Reddit */
        var redditIframe = document.createElement('iframe');
        redditIframe.setAttribute('src', 'http://reddit.com/button?t=2&url=' + currentPageUrl);
        redditIframe.setAttribute('height', '80');
        redditIframe.setAttribute('width', '52');
        redditIframe.setAttribute('frameborder', '0');
        redditIframe.setAttribute('scrolling', 'no');
        redditIframe.setAttribute('style', 'margin-left:auto; margin-right:auto; display:block; text-align:center;');

        var div = document.createElement('div');
        div.appendChild(dotnetkicksLink);
        div.appendChild(document.createElement('br'));
        div.appendChild(diggIframe);
        div.appendChild(document.createElement('br'));
        div.appendChild(redditIframe);

        document.write(div.innerHTML);
    </script>
</div>
<p><b>What's so Magic about LINQ to SQL?</b></p>
<p>LINQ to SQL (and it's more powerful unreleased cousin <a href="http://blogs.msdn.com/adonet/archive/2007/01/30/entity-data-model-part-1.aspx">LINQ to Entities</a>) is a new Object Relational Mapping (<a href="http://en.wikipedia.org/wiki/Object-relational_mapping">ORM</a>) technology from Microsoft. It allows you to write something like the following:</p>
<p><span style="FONT-SIZE: 10pt; COLOR: #2b91af; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">IEnumerable</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">&lt;<span style="COLOR: #2b91af">Product</span>&gt; products = northwindDataContext.Products.Where(<br /><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>p =&gt; p.Category.CategoryName == <span style="COLOR: #a31515">"Beverages"<br /></span><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>);</span></p>
<p>Which as you'd expect returns products from the database whose category is Beverages. But wait, aren't you impressed? If not read over that code again, you should be very impressed. In the background that C# code is converted into the following SQL:</p>
<p><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">SELECT</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes"> [t0]<span style="COLOR: gray">.</span>[ProductID]<span style="COLOR: gray">,</span> [t0]<span style="COLOR: gray">.</span>[ProductName]<span style="COLOR: gray">,</span> <span style="COLOR: gray">...<br /></span><span style="COLOR: blue">FROM</span> [dbo]<span style="COLOR: gray">.</span>[Products] <span style="COLOR: blue">AS</span> [t0]<br /><span style="COLOR: gray">LEFT</span> <span style="COLOR: gray">OUTER</span> <span style="COLOR: gray">JOIN</span> [dbo]<span style="COLOR: gray">.</span>[Categories] <span style="COLOR: blue">AS</span> [t1] <br /><span style="COLOR: blue">ON</span> [t1]<span style="COLOR: gray">.</span>[CategoryID] <span style="COLOR: gray">=</span> [t0]<span style="COLOR: gray">.</span>[CategoryID]<br /><span style="COLOR: blue">WHERE</span> [t1]<span style="COLOR: gray">.</span>[CategoryName] <span style="COLOR: gray">=</span> @p0</span></p>
<p>In other words it's pretty smart. It isn't just returning all products and filtering them in memory using the LINQ to Objects version of Where() I discussed <a href="http://rapidapplicationdevelopment.blogspot.com/2008/03/how-systemlinqwhere-really-works.html">previously</a>.</p>
<p>Doing something like that using NHibernate Criteria would require something like this:</p>
<p><span style="FONT-SIZE: 10pt; COLOR: #2b91af; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">ICriteria</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes"> c = session.CreateCriteria(<span style="COLOR: blue">typeof</span>(<span style="COLOR: #2b91af">Product</span>));<br />c.Add(<span style="COLOR: #2b91af">Expression</span>.Eq(<span style="COLOR: #a31515">"Category.CategoryName"</span>, <span style="COLOR: #a31515">"Beverages"</span>));<br /><span style="COLOR: #2b91af">IEnumerable</span>&lt;<span style="COLOR: #2b91af">Product</span>&gt; products = c.List&lt;<span style="COLOR: #2b91af">Product</span>&gt;();</span></p>
<p>You could use HQL too, but both NHibernate options suffer from the same problem. Did you spot it? </p>
<p>The LINQ to SQL version is taking actual <i>strongly typed</i> C# code and somehow smartly converting it to useful SQL. The NHibernate version does the same thing, but always using a <i>weakly typed</i> alternative. In other words the column "CategoryName" in NHibernate is a string. If it or its data type change in NHibernate you won't find out until runtime. And that is the beauty of LINQ to SQL: you'll find more errors at compile time. And if you're like me you want the compiler to find your mistakes before the unit tests that you (or your fellow developers) may or may not have written do. </p>
<p>So you're probably now wondering if you can put strongly typed C# in your where clause and it somehow magically gets converted to SQL, what's the limit? If you put in a String.ToLower() or StartsWith() will it get converted to equivalent SQL? What about a loop or conditional? A function call? A recursive function call? At some point it has to break down and either return all products and filter them in memory or just fail right? Before answering those questions we need to understand what's going on.</p>
<p><b>Understanding the Magic</b></p>
<p>The Magic happens in a class called <a href="http://msdn2.microsoft.com/en-us/library/bb335710.aspx">Expression&lt;T&gt;</a>. Expression takes a generic argument that must be a delegate and is usually one of the built in <a href="http://rapidapplicationdevelopment.blogspot.com/2008/03/how-systemlinqwhere-really-works.html">Func</a> methods.&nbsp; However the class can only be instantiated to a lambda expression. That's right, not a delegate or anonymous method, only a Lambda expression. So in my <a href="http://rapidapplicationdevelopment.blogspot.com/2008/02/deferred-execution-elegance-of-linq.html">deferred execution</a> post where I explained what Lambda expression are, I said they were <i>essentially</i> syntactic sugar for an anonymous methods. Well, the emphasis is on the essentially, because they really aren't sugar at all. When you assign a lambda expression to an Expression, the compiler, rather than generating the IL to evaluate the expression, generates IL that constructs an <a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a> (AST) for the expression! You can then parse the tree and perform actions based on the code in the lambda expression. </p>
<p>Below is an example adapted from the <a href="http://msdn2.microsoft.com/en-us/library/bb397951.aspx">.Net Developer's guide</a> on MSDN that shows how this works:</p>
<p><span style="FONT-SIZE: 10pt; COLOR: green; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">// convert the lambda expression to an abstract syntax tree<br /></span><span style="FONT-SIZE: 10pt; COLOR: #2b91af; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">Expression</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">&lt;<span style="COLOR: #2b91af">Func</span>&lt;<span style="COLOR: blue">int</span>, <span style="COLOR: blue">bool</span>&gt;&gt; expression = i =&gt; i &lt; 5;<br /><br /><span style="COLOR: #2b91af">ParameterExpression</span> param = (<span style="COLOR: #2b91af">ParameterExpression</span>)expression.Parameters[0];<br /><span style="COLOR: green">// this next line would fail if we change the Lambda expression much<br /></span><span style="COLOR: #2b91af">BinaryExpression</span> operation = (<span style="COLOR: #2b91af">BinaryExpression</span>)expression.Body;<br /><span style="COLOR: #2b91af">ParameterExpression</span> left = (<span style="COLOR: #2b91af">ParameterExpression</span>)operation.Left;<br /><span style="COLOR: #2b91af">ConstantExpression</span> right = (<span style="COLOR: #2b91af">ConstantExpression</span>)operation.Right;<br /><br /><span style="COLOR: #2b91af">Console</span>.WriteLine(<span style="COLOR: #a31515">"Decomposed expression: {0} =&gt; {1} {2} {3}"</span>,<br /><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>param.Name, <br /><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>left.Name, <br /><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>operation.NodeType, <br /><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>right.Value<br /><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>);</span></p>
<p>This outputs "Decomposed expression: i =&gt; i LessThan 5". The first line is the most important. It defines an Expression that takes a delegate with a single int parameter and a return type of bool. It then instantiates the Expression to a simple lambda expression.&nbsp; Incidentally this would also work if we defined our own Delegate:</p>
<p><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">public</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes"> <span style="COLOR: blue">delegate</span> <span style="COLOR: blue">bool</span> <span style="COLOR: #2b91af">LessThanFive</span>(<span style="COLOR: blue">int</span> i);<br /><br /><span style="COLOR: blue">public</span> <span style="COLOR: blue">static</span> <span style="COLOR: blue">void</span> DoStuff() {<br /><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: #2b91af">Expression</span>&lt;<span style="COLOR: #2b91af">LessThanFive</span>&gt; expression = i =&gt; i &lt; 5;<br />}</span></p>
<p>It would, however, not work if we used an anonymous method:</p>
<p><span style="FONT-SIZE: 10pt; COLOR: #2b91af; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">Expression</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">&lt;<span style="COLOR: #2b91af">Func</span>&lt;<span style="COLOR: blue">int</span>, <span style="COLOR: blue">bool</span>&gt;&gt; expression = <span style="COLOR: blue">delegate</span>(<span style="COLOR: blue">int</span> i) { <span style="COLOR: blue">return</span> i &lt; 5; };</span></p>
<p>While that looks legal it actually results in the compile time error "An anonymous method expression cannot be converted to an expression tree."</p>
<p>There is a lot of complexity in parsing the AST, far beyond the scope of this article. However, the MSDN does have a nice diagram that helps explain how the following slightly more complicated Lambda expression that determines if a string has more letters than a number:</p>
<p><span style="FONT-SIZE: 10pt; COLOR: #2b91af; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">Expression</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">&lt;<span style="COLOR: #2b91af">Func</span>&lt;<span style="COLOR: blue">string</span>, <span style="COLOR: blue">int</span>, <span style="COLOR: blue">bool</span>&gt;&gt; expression =<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>(str, num) =&gt; num &gt; str.Length;</span></p>
<p><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://bp0.blogger.com/_gez10dNhuPk/R-wLZwVrWwI/AAAAAAAAAoo/OSpE74pLxxc/s1600-h/ExpressionTrees.png"><img id="BLOGGER_PHOTO_ID_5182529808297057026" style="CURSOR: hand" alt="" src="http://bp0.blogger.com/_gez10dNhuPk/R-wLZwVrWwI/AAAAAAAAAoo/OSpE74pLxxc/s400/ExpressionTrees.png" border="0" /></a></p>
<p><b>How Deep Does The Rabbit Hole Go?</b></p>
<p>So LINQ to SQL uses this Expression Tree technique to parse a plethora of possible code that you could throw at it and turn it into smart SQL. For instance check out a couple of the following conversions that LINQ to SQL will (or will not) perform:</p>
<p><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">p =&gt; p.Category.CategoryName.ToLower() == <span style="COLOR: #a31515">"beverages"</span></span></p>
<p>Results In:</p>
<p><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">SELECT</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes"> [t0]<span style="COLOR: gray">.</span>[ProductID]<span style="COLOR: gray">,</span> <span style="COLOR: gray">...<br /></span><span style="COLOR: blue">FROM</span> [dbo]<span style="COLOR: gray">.</span>[Products] <span style="COLOR: blue">AS</span> [t0]<br /><span style="COLOR: gray">LEFT</span> <span style="COLOR: gray">OUTER</span> <span style="COLOR: gray">JOIN</span> [dbo]<span style="COLOR: gray">.</span>[Categories] <span style="COLOR: blue">AS</span> [t1] <span style="COLOR: blue">ON</span> [t1]<span style="COLOR: gray">.</span>[CategoryID] <span style="COLOR: gray">=</span> [t0]<span style="COLOR: gray">.</span>[CategoryID]<br /><span style="COLOR: blue">WHERE</span> <span style="COLOR: fuchsia">LOWER</span><span style="COLOR: gray">(</span>[t1]<span style="COLOR: gray">.</span>[CategoryName]<span style="COLOR: gray">)</span> <span style="COLOR: gray">=</span> @p0</span></p>
<p>Not bad, huh? How about:</p>
<p><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">p =&gt; p.Category.CategoryName.Contains(<span style="COLOR: #a31515">"everage"</span>)</span></p>
<p>That results in the following SQL snippet:</p>
<p><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">WHERE</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes"> [t1]<span style="COLOR: gray">.</span>[CategoryName] <span style="COLOR: gray">LIKE</span> @p0</span></p>
<p>And it sets @p0 to "%everage%". Pretty cool. Ok this will get it to fail though, right?</p>
<p><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">public</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes"> <span style="COLOR: blue">static</span> <span style="COLOR: blue">string</span> GetCat() {<br /><span style="COLOR: blue"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>return</span> <span style="COLOR: #a31515">"Beverages"</span>;<br />}<br /><br /><span style="COLOR: #2b91af">IEnumerable</span>&lt;<span style="COLOR: #2b91af">Product</span>&gt; products = northwindDataContext.Products.Where(<br /><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>p =&gt; p.Category.CategoryName == GetCat()<br /><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>);</span></p>
<p>It turns out that LINQ to SQL will look inside of other functions! Alright, there's no way it can do complicated conditionals:</p>
<p><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">p =&gt; p.Category.CategoryName == <br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span><span style="COLOR: #a31515">"Beverages"</span> ? p.UnitsInStock &lt; 5 : !p.Discontinued</span></p>
<p>This should only pick up Beverages that have fewer than 5 items in stock regardless of whether they are discontinued and any other products that aren't discontinued. Would you believe that it runs a single SQL statement:</p>
<p><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">SELECT</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes"> [t0]<span style="COLOR: gray">.</span>[ProductID]<span style="COLOR: gray">,</span> ...<br /><span style="COLOR: blue">FROM</span> [dbo]<span style="COLOR: gray">.</span>[Products] <span style="COLOR: blue">AS</span> [t0]<br /><span style="COLOR: gray">LEFT</span> <span style="COLOR: gray">OUTER</span> <span style="COLOR: gray">JOIN</span> [dbo]<span style="COLOR: gray">.</span>[Categories] <span style="COLOR: blue">AS</span> [t1] <span style="COLOR: blue">ON</span> [t1]<span style="COLOR: gray">.</span>[CategoryID] <span style="COLOR: gray">=</span> [t0]<span style="COLOR: gray">.</span>[CategoryID]<br /><span style="COLOR: blue">WHERE</span> <span style="COLOR: gray">(<br /></span><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span><span style="COLOR: gray">(</span><span style="COLOR: blue">CASE</span> <br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">WHEN</span> [t1]<span style="COLOR: gray">.</span>[CategoryName] <span style="COLOR: gray">=</span> @p0 <span style="COLOR: blue">THEN</span> <br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: gray">(</span><span style="COLOR: blue">CASE</span> <br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">WHEN</span> [t0]<span style="COLOR: gray">.</span>[UnitsInStock] <span style="COLOR: gray">&lt;</span> @p1 <span style="COLOR: blue">THEN</span> 1<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">WHEN</span> <span style="COLOR: gray">NOT</span> <span style="COLOR: gray">(</span>[t0]<span style="COLOR: gray">.</span>[UnitsInStock] <span style="COLOR: gray">&lt;</span> @p1<span style="COLOR: gray">)</span> <span style="COLOR: blue">THEN</span> 0<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">ELSE</span> <span style="COLOR: gray">NULL<br /></span><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">END</span><span style="COLOR: gray">)<br /></span><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">ELSE</span> <span style="COLOR: fuchsia">CONVERT</span><span style="COLOR: gray">(</span><span style="COLOR: blue">Int</span><span style="COLOR: gray">,<br /></span><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: gray">(</span><span style="COLOR: blue">CASE</span> <br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">WHEN</span> <span style="COLOR: gray">NOT</span> <span style="COLOR: gray">(</span>[t0]<span style="COLOR: gray">.</span>[Discontinued] <span style="COLOR: gray">=</span> 1<span style="COLOR: gray">)</span> <span style="COLOR: blue">THEN</span> 1<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">WHEN</span> <span style="COLOR: gray">NOT</span> <span style="COLOR: gray">NOT</span> <span style="COLOR: gray">(</span>[t0]<span style="COLOR: gray">.</span>[Discontinued] <span style="COLOR: gray">=</span> 1<span style="COLOR: gray">)</span> <span style="COLOR: blue">THEN</span> 0<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">ELSE</span> <span style="COLOR: gray">NULL<br /></span><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">END</span><span style="COLOR: gray">))<br /></span><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">END</span><span style="COLOR: gray">))</span> <span style="COLOR: gray">=</span> 1</span></p>
<p>Wow, it sure isn't pretty, but it scales to multiple conditionals, and most importantly it didn't return all products and process them in memory. Not bad.</p>
<p><b>Conclusion</b></p>
<p>I asserted up front that using expression trees and the strong typing that comes with them is the reason LINQ to SQL is inherently better that NHibernate. I really can't make that claim without admitting one of LINQ to SQL's biggest shortcomings: It currently does not support <a href="http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=299807">multiple table inheritance</a>. Ultimately, however, it's a short term fault since the forthcoming LINQ to Entities does. And I stand by my claim because from a long term perspective as long as technologies like NHibernate remain pure ports of Java code they will never realize the full benefits of equivelant LINQ technologies that take advantage of .Net's native strengths: like expression trees.</p>
<hr>

<p>Note: Please post comments to my <a href="http://rapidapplicationdevelopment.blogspot.com/2008/03/expression-trees-why-linq-to-sql-is.html">blogspot blog</a></p> 
{% endraw %}
