--- 
permalink: /blogs/lee_richardson/death_to_the_dao_and_how_to_te.html
layout: blogs
title: Death to the DAO and How to Test LINQ
date: 2010-07-22 22:42:43 -04:00
tags: .NET
---
{% raw %}
<p>Occasionally I hear complaints that LINQ is hard to unit test.  These complaints aren't about LINQ to objects, mind you, they're specific to the complexities of the flavors of LINQ that turn C# code into something else like SQL or CAML using <a href="http://rapidapplicationdevelopment.blogspot.com/2008/03/expression-trees-why-linq-to-sql-is.html">expression trees</a>.  The most common technologies are LINQ to SQL, the Entity Framework, or in my case at the moment LINQ to SharePoint.  In this post I'm going to propose a technique that makes testing LINQ not just easy, but downright elegant - assuming you're ok with extension methods - lots of extension methods.  And assuming you're ready to kill your Data Access Objects (DAO) tier.</p>

<div style='float:right; margin-left:10px;'>
<script type='text/javascript'>
        var currentPageUrl = 'http://rapidapplicationdevelopment.blogspot.com/2010/07/death-to-dao-and-how-to-test-linq.html';

        /* Digg */
        var diggIframe = document.createElement('iframe');
        diggIframe.setAttribute('src', 'http://digg.com/tools/diggthis.php?u=' + currentPageUrl);
        diggIframe.setAttribute('height', '80');
        diggIframe.setAttribute('width', '52');
        diggIframe.setAttribute('frameborder', '0');
        diggIframe.setAttribute('scrolling', 'no');
        diggIframe.setAttribute('style', 'margin-left:auto; margin-right:auto; display:block; text-align:center;');

        /* DotNetKicks */
        var dotnetkicksLink = document.createElement('a');
        dotnetkicksLink.setAttribute('href', 'http://www.dotnetkicks.com/kick/?url=' + currentPageUrl);
        var dotnetkicksImg = document.createElement('img');
        dotnetkicksImg.setAttribute('src', 'http://www.dotnetkicks.com/Services/Images/KickItImageGenerator.ashx?url=' + currentPageUrl);
        dotnetkicksImg.setAttribute('alt', 'Kick this article (a good thing) on DotNetKicks');
        dotnetkicksImg.setAttribute('border', '0');
        dotnetkicksImg.setAttribute('style', 'margin-left:auto; margin-right:auto; display:block; text-align:center;');
        dotnetkicksLink.appendChild(dotnetkicksImg);

        var div = document.createElement('div');
        div.appendChild(dotnetkicksLink);
        div.appendChild(document.createElement('br'));
        div.appendChild(diggIframe);

        document.write(div.innerHTML);
    </script>
</div>


<p><b>The Unit Testing Problem</b></p><p>Any architecture needs a place to put code that finds entities.  For instance FindBySocialSecurityNumber().  In a traditional architecture we might put a method like this is in a DAO layer.  If so our method will look something like this:</p><p><span style="font-size:9.5pt;line-height:115%;font-family:Consolas;mso-fareast-font-family:Calibri;mso-fareast-theme-font:minor-latin;color:blue;mso-ansi-language:EN-US;mso-fareast-language:EN-US;mso-bidi-language:AR-SA">public</span><span style="font-size:9.5pt;line-height:115%;font-family:Consolas;mso-fareast-font-family:Calibri;mso-fareast-theme-font:minor-latin;mso-ansi-language:EN-US;mso-fareast-language:EN-US;mso-bidi-language:AR-SA"> <span style="color:blue">class</span> <span style="color:#2B91AF"> EmployeesDao</span> {<br /> <span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp; </span><span style="color:blue">public</span> <span style="color:#2B91AF">Employee</span> FindBySSN(<span   style="color:#2B91AF">Context</span> ctx, <span style="color:blue">string</span>  ssn) {<br /> <span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:blue">return</span>  ctx.Employees.SingleOrDefault(e =&gt; e.Ssn == ssn);<br /> <span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp; </span>}<br /> }</span></p><p>So how would we go about unit testing this?</p><p>One fairly typical solution would be to use an in-memory database.  That approach works if our data store is a database, but it certainly doesn't work if the data store is something less traditional like SharePoint.  But even if our store is a database, we'll still have the hassle of setting up the in-memory database.</p><p>Another solution might be to use a mock Context that returns an IQueryable<Employee>.  But wouldn't it be wonderful if we could avoid mocking all together?</p><p><b>Killing the DAO</b></p><p>The first question is why we even have a DAO tier to begin with.  The original idea was that we wanted a place to put code specific to a particular data store.  In other words we wanted to isolate the code that will need to be changed should the data store switch from SQL Server to Oracle.  But isn't that exactly what LINQ does?  I'd be pretty surprised if there wasn't a decent LINQ provider for just about any data store at this point that required more than minimal code changes.  So why not embrace LINQ and reconsider alternatives to a DAO tier?</p><p>One alternative that I've been using for over a month now is to switch to extension methods.  To give credit where it's due the idea originated with a conversation with fellow <a href="http://www.nearinfinity.com">Near Infinity</a> employee <a href="http://www.nearinfinity.com/blogs/joe_ferner/">Joe Ferner</a>.  And I'm sure the idea isn't particularly original (please post in the comments if you know others that use this approach).</p><p>Using this technique our code changes from something like this:</p><p><span style="font-size:9.5pt;line-height:115%;font-family:Consolas;mso-fareast-font-family:Calibri;mso-fareast-theme-font:minor-latin;color:blue;mso-ansi-language:EN-US;mso-fareast-language:EN-US;mso-bidi-language:AR-SA">var</span><span style="font-size:9.5pt;line-height:115%;font-family:Consolas;mso-fareast-font-family:Calibri;mso-fareast-theme-font:minor-latin;mso-ansi-language:EN-US;mso-fareast-language:EN-US;mso-bidi-language:R-SA"> employeeDao = <span style="color:blue">new</span> <span style="color:#2B91AF">EmployeesDao</span>(); <span style="color:green">//  or use IOC of course<br /> </span>employeeDao.FindBySSN(ctx, <span style="color:#A31515">&quot;111-11-1111&quot;</span>);</span></p><p>To something like this:</p><p><span style="font-size:9.5pt;line-height:115%;font-family:Consolas;mso-fareast-font-family:Calibri;mso-fareast-theme-font:minor-latin;mso-ansi-language:EN-US;mso-fareast-language:EN-US;mso-bidi-language:AR-SA">ctx.Employees.FindBySSN(<span style="color:#A31515">&quot;111-11-1111&quot;</span>);</span></p><p>Among other things I find this far more aesthetically pleasing because each of the three elements to the statement represent a subsequent filtering of data.  It's a more functional way of looking at things.</p><p>We could implement this off of the Employees property of the context if we have control over that (which I don't with spmetal). But if we implement this as an extension method like this:</p><p><span style="font-size:9.5pt;line-height:115%;font-family:Consolas;mso-fareast-font-family:Calibri;mso-fareast-theme-font:minor-latin;color:blue;mso-ansi-language:EN-US;mso-fareast-language:EN-US;mso-bidi-language:AR-SA">public</span><span style="font-size:9.5pt;line-height:115%;font-family:Consolas;mso-fareast-font-family:Calibri;mso-fareast-theme-font:minor-latin;mso-ansi-language:EN-US;mso-fareast-language:EN-US;mso-bidi-language:AR-SA"> <span style="color:blue">static</span> <span style="color:blue">class</span> <span style="color:#2B91AF">EmployeeExtensions</span> {<br /> <span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp; </span><span style="color:blue">public</span> <span style="color:blue">static</span> <span style="color:#2B91AF">Employee</span>  FindBySSN(<span style="color:blue">this</span> <span style="color:#2B91AF"> IQueryable</span>&lt;<span style="color:#2B91AF">Employee</span>&gt; employees, <span style="color:blue">string</span> ssn) {<br /> <span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:blue">return</span>  employees.SingleOrDefault(e =&gt; e.Ssn == ssn);<br /> <span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp; </span>}<br /> }</span></p><p>We now have something that's considerable easier to unit test.</p><p><b>Testing It</b></p><p>Once we've refactored our function as an extension method that filters down the corpus of entities, we can test the code using in-memory objects with a call to .AsQueryable().  For instance:</p><p><span style="font-size:9.5pt;line-height:115%;font-family:Consolas;mso-fareast-font-family:Calibri;mso-fareast-theme-font:minor-latin;color:blue;mso-ansi-language:EN-US;mso-fareast-language:EN-US;mso-bidi-language:AR-SA">public</span><span style="font-size:9.5pt;line-height:115%;font-family:Consolas;mso-fareast-font-family:Calibri;mso-fareast-theme-font:minor-latin;mso-ansi-language:EN-US;mso-fareast-language:EN-US;mso-bidi-language:R-SA"> <span style="color:blue">void</span>  FindBySSN_OneSsnExists_EmployeeReturned() {<br /> <span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:blue">var</span>  employees = <span style="color:blue">new</span> [] { <span style="color:blue"> new</span> <span style="color:#2B91AF">Employee</span> { Ssn = <span style="color:#A31515">&quot;111-11-1111&quot;</span> } };<br /> <span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:blue">var</span>  actual = employees.AsQueryable().FindBySSN(<span style="color:#A31515">&quot;111-11-1111&quot;</span>);<br /> <span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#2B91AF">Assert</span>.IsNotNull(actual); <br /> }</span></p><p>Notice we didn't have to mock anything.</p><p><b>Testability, but at What Cost?</b></p><p>This technique works great for the example above, but how does it scale to harder problems and what other downsides are there?</p><p>As far as scalability I've found this technique works great for every scenario I've run across in the month I've been doing it.  It works for joins, aggregations, and even for inserts, update, and deletes.</p><p>As far as downsides the astute reader may be wondering about mockability.  For instance what if we want to mock the call to FindBySSN and give it the exact Employee that will be returned.  This scenario is admittedly harder.  But what I've found is that far more often than not I don't really need to mock the types of things that used to live in the DAO tier.  Instead I just mock the Employee object off of context to return in-memory objects and make my tests slightly larger in scope.  Most of the time I find the larger scope increases the usefulness of the test.  In the occasional case where I do really want to mock the "DAO" tier I use a technique described in <a href=" http://www.clariusconsulting.net/blogs/kzu/archive/2009/02/19/Makingextensionmethodsamenabletomocking.aspx">this post</a> by Daniel Cazzulino.</p><p><b>Conclusion</b></p><p>Obviously there is more to this architecture, for instance how do you handle insert and update operations?  The short answer is it's easy, but I'll save that topic for a future post.  For now why not give this approach a try?  You weren't really happy with that useless old DAO tier anyway, were you?  I say we eradicate it and never look back.</p> 
{% endraw %}
