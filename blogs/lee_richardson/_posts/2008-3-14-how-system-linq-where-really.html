--- 
permalink: /blogs/how_system_linq_where_really.html
layout: blogs
title: How System.Linq.Where() Really Works
date: 2008-03-14 14:53:47 -04:00
tags: .NET
---
<p>After writing my last blog entry on <a href="http://rapidapplicationdevelopment.blogspot.com/2008/02/deferred-execution-elegance-of-linq.html">Deferred Execution in LINQ</a> I had a conversation with <a href="http://www.nearinfinity.com/blogs/page/seths">Seth Schroeder</a> who rightly pointed out among other things that I really didn't show how LINQ's deferred execution works internally. So in this post I wanted to implement my own LINQ <i>Where()</i> extension method based off of the one in the System.Linq namespace. So I'll show you the code, explain interesting parts of how it works including collection initializiers and extension methods, and then explain where the deferred execution behavior comes from (i.e. the yield statement). I will only explain in the context of LINQ to Objects since that's far simpler than other Linq's. I will implement a Where() like LINQ to SQL does in a later blog post (that's where things get really crazy).</p>
<div style="FLOAT: right; MARGIN-LEFT: 10px">
<script type="text/javascript">
        var currentPageUrl = 'http://rapidapplicationdevelopment.blogspot.com/2008/03/how-systemlinqwhere-really-works.html';

        /* Digg */
        var diggIframe = document.createElement('iframe');
        diggIframe.setAttribute('src', 'http://digg.com/tools/diggthis.php?u=' + currentPageUrl);
        diggIframe.setAttribute('height', '80');
        diggIframe.setAttribute('width', '52');
        diggIframe.setAttribute('frameborder', '0');
        diggIframe.setAttribute('scrolling', 'no');
        diggIframe.setAttribute('style', 'margin-left:auto; margin-right:auto; display:block; text-align:center;');

        /* DotNetKicks */
        var dotnetkicksLink = document.createElement('a');
        dotnetkicksLink.setAttribute('href', 'http://www.dotnetkicks.com/kick/?url=' + currentPageUrl);
        var dotnetkicksImg = document.createElement('img');
        dotnetkicksImg.setAttribute('src', 'http://www.dotnetkicks.com/Services/Images/KickItImageGenerator.ashx?url=' + currentPageUrl);
        dotnetkicksImg.setAttribute('alt', 'Kick this article (a good thing) on DotNetKicks');
        dotnetkicksImg.setAttribute('border', '0');
        dotnetkicksImg.setAttribute('style', 'margin-left:auto; margin-right:auto; display:block; text-align:center;');
        dotnetkicksLink.appendChild(dotnetkicksImg);

        var div = document.createElement('div');
        div.appendChild(diggIframe);
        div.appendChild(document.createElement('br'));
        div.appendChild(dotnetkicksLink);

        document.write(div.innerHTML);
    </script>
</div>
<p><b>Implementing MyWhere()</b></p>
<p>Let's start out with some code. The first question is does this compile?</p>
<p><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">using</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes"> System;<br /><span style="COLOR: blue">using</span> System.Collections.Generic;<br /><span style="COLOR: blue">using</span> MyExtensionMethods;<br /><br /><span style="COLOR: blue">namespace</span> PlayingWithLinq {<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">public</span> <span style="COLOR: blue">class</span> <span style="COLOR: #2b91af">LinqToObjects</span> {<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">public</span> <span style="COLOR: blue">static</span> <span style="COLOR: blue">void</span> DoStuff() {<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: #2b91af">IList</span>&lt;<span style="COLOR: blue">int</span>&gt; ints = <span style="COLOR: blue">new</span> <span style="COLOR: #2b91af">List</span>&lt;<span style="COLOR: blue">int</span>&gt;() {9,8,7,6,5,4,3,2,1};<br /><br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: #2b91af">IEnumerable</span>&lt;<span style="COLOR: blue">int</span>&gt; result = ints.MyWhere(i =&gt; i &lt; 5);<br /><br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">foreach</span> (<span style="COLOR: blue">int</span> i <span style="COLOR: blue">in</span> result) {<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: #2b91af">Console</span>.WriteLine(i);<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>}<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>}<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>}<br />}<br /><br /><span style="COLOR: blue">namespace</span> MyExtensionMethods {<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">public</span> <span style="COLOR: blue">static</span> <span style="COLOR: blue">class</span> <span style="COLOR: #2b91af">ExtensionMethods</span> {<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">public</span> <span style="COLOR: blue">static</span> <span style="COLOR: #2b91af">IEnumerable</span>&lt;TSource&gt; MyWhere&lt;TSource&gt;(<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">this</span> <span style="COLOR: #2b91af">IEnumerable</span>&lt;TSource&gt; source,<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: #2b91af">Func</span>&lt;TSource, <span style="COLOR: blue">bool</span>&gt; predicate<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>) {<br /><br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">foreach</span> (TSource element <span style="COLOR: blue">in</span> source) {<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">if</span> (predicate(element)) {<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">yield</span> <span style="COLOR: blue">return</span> element;<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>}<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>}<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>}<br /><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>}<br />}</span></p>
<p>Side note: putting two namespaces in on file is far from a best practice, but yes that is allowed. </p>
<p><b>Lambdas and Collection Initializers</b></p>
<p>If you're new to C# 3.5 then your first thought may be that:</p>
<p><span style="FONT-SIZE: 10pt; COLOR: #2b91af; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">IList</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">&lt;<span style="COLOR: blue">int</span>&gt; ints = <span style="COLOR: blue">new</span> <span style="COLOR: #2b91af">List</span>&lt;<span style="COLOR: blue">int</span>&gt;() {9,8,7,6,5,4,3,2,1};</span></p>
<p>is not allowed. Actually it is. It's the <a href="http://weblogs.asp.net/scottgu/archive/2007/03/08/new-c-orcas-language-features-automatic-properties-object-initializers-and-collection-initializers.aspx">collection initializer syntax</a> that I initially whined about in my post <a href="http://rapidapplicationdevelopment.blogspot.com/2007/04/c-30-sweet-and-sour-of-syntactic-sugar.html">C# 3.0: The Sweet and Sour of Syntactic Sugar</a> (ironically I actually like this syntax the more I use it.)</p>
<p>Your next thought may be that:</p>
<p><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">i =&gt; i &lt; 5</span></p>
<p>is not legitimate. This is in fact a <a href="http://weblogs.asp.net/scottgu/archive/2007/04/08/new-orcas-language-feature-lambda-expressions.aspx">Lambda Expression</a>, and as I explained in <a href="http://rapidapplicationdevelopment.blogspot.com/2008/02/deferred-execution-elegance-of-linq.html">Deferred Execution, The Elegance of LINQ </a>it conceptually compiles down to an anonymous method. Incidentally those that know Groovy (myself not included) or Lisp may know this as a <a href="http://en.wikipedia.org/wiki/Closure_(computer_science)">closure</a> since as we'll see later it can access local variables.</p>
<p><b>Extension Methods</b></p>
<p>Ok, the .Net Framework certainly has no MyWhere() function on the List object so this certainly wouldn't compile in C# 2. But that's where C# 3's <a href="http://weblogs.asp.net/scottgu/archive/2007/03/13/new-orcas-language-feature-extension-methods.aspx">Extension Methods</a> come in. The "this" in:</p>
<p><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">MyWhere&lt;TSource&gt;(<b style="mso-bidi-font-weight: normal"><span style="COLOR: blue">this</span></b> <span style="COLOR: #2b91af">IEnumerable</span><b style="mso-bidi-font-weight: normal">&lt;TSource&gt; source</b>,</span></p>
<p>says that MyWhere() can be applied to any generic IEnumerable. If you want to, you can still call MyWhere() normally:</p>
<p><span style="FONT-SIZE: 10pt; COLOR: #2b91af; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">IList</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">&lt;<span style="COLOR: blue">int</span>&gt; ints = <span style="COLOR: blue">new</span> <span style="COLOR: #2b91af">List</span>&lt;<span style="COLOR: blue">int</span>&gt;() {9,8,7,6,5,4,3,2,1};<br /><span style="COLOR: #2b91af">ExtensionMethods</span>.MyWhere(ints, i =&gt; i &lt; 5);</span></p>
<p>And in fact this is what the compiler does in the background when you call MyWhere() off of an IEnumerable. But now with extension methods you don't have to.</p>
<p>But does MyWhere() now exist on all IEnumerable objects everywhere? No, it turns out you only get MyWhere() when you import the namespace it exists in (MyExtensionMethods). Incidentally unlike Groovy and Ruby there is no way to add an extension method to a class itself, only to instances.</p>
<p><b>Whose got the Func()?</b></p>
<p>The last two questionable parts of the code are the Func&lt;TSource, bool&gt; and the yield. Func is pretty easy. It's simply one of several new predefined <a href="http://en.wikipedia.org/wiki/Delegate_(.NET)">delegates</a> (method signatures) that comes with the .Net framework off of the System namespace. The two generic argument one above will match any function that returns the second generic argument and takes the first generic argument as a parameter. It looks like this:</p>
<p><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">delegate</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes"> TResult <span style="COLOR: #2b91af">Func</span>&lt;T, TResult&gt;(T arg1);</span></p>
<p>So rather than using a Lambda expression in my initial example I could have been very explicit about the delegate instance (myFunc):</p>
<p><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">public</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes"> <span style="COLOR: blue">static</span> <span style="COLOR: blue">void</span> DoStuff() {<br /><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: #2b91af">IList</span>&lt;<span style="COLOR: blue">int</span>&gt; ints = <span style="COLOR: blue">new</span> <span style="COLOR: #2b91af">List</span>&lt;<span style="COLOR: blue">int</span>&gt;() {9,8,7,6,5,4,3,2,1};<br /><br /><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><b style="mso-bidi-font-weight: normal"><span style="COLOR: #2b91af">Func</span>&lt;<span style="COLOR: blue">int</span>, <span style="COLOR: blue">bool</span>&gt; myFunc = IsSmall;<br /></b><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: #2b91af">IEnumerable</span>&lt;<span style="COLOR: blue">int</span>&gt; result = ints.MyWhere&lt;<span style="COLOR: blue">int</span>&gt;(<b style="mso-bidi-font-weight: normal">myFunc</b>);<br /><br /><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">foreach</span> (<span style="COLOR: blue">int</span> i <span style="COLOR: blue">in</span> result) {<br /><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: #2b91af">Console</span>.WriteLine(i);<br /><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>}<br />}<br /><br /><span style="COLOR: blue">public</span> <span style="COLOR: blue">static</span> <span style="COLOR: blue">bool</span> IsSmall(<span style="COLOR: blue">int</span> i) {<br /><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: blue">return</span> i &lt; 5;<br />}</span></p>
<p>And that would have done the same thing. Notice I had to specify the generic type on the call to MyWhere() since the compiler can't infer the type in this example.</p>
<p><b>Yield</b></p>
<p>Now the really interesting part: <a href="http://msdn2.microsoft.com/en-us/library/9k7k7cf0.aspx">yield</a>. Yield is what makes deferred execution work. It actually was introduced with C# 2.0, but I don't think anyone really used it (I didn't know about it until recently). So because MyWhere() returns an IEnumerable (and because it isn't anonymous and doesn't have ref or out parameters) it is allowed to use the yield statement. When a method has a yield return (or yield break) statement, then execution of the method doesn't even begin until a calling method first iterates over the resulting IEnumerable. Execution then begins in the method and runs to the first yield statement, returns a result, and passes execution back to the caller. When the calling method iterates to the next value execution continues in the method where it left off until it gets to the next yield statement and then it passes execution back to the caller again and so on. Weird huh? <a href="">Joshua Flanagan</a> has a nice article that explains this in more detail along with some of the nice benefits like a smaller memory footprint.</p>
<p>So here's a quiz. What happens when you execute the following code?</p>
<p><span style="FONT-SIZE: 10pt; COLOR: #2b91af; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">IList</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">&lt;<span style="COLOR: blue">int</span>&gt; ints = <span style="COLOR: blue">new</span> <span style="COLOR: #2b91af">List</span>&lt;<span style="COLOR: blue">int</span>&gt;() {9,8,7,6,5,4,3,2,1};<br /><br /><span style="COLOR: #2b91af">IEnumerable</span>&lt;<span style="COLOR: blue">int</span>&gt; result = ints.MyWhere&lt;<span style="COLOR: blue">int</span>&gt;(i =&gt; i &lt; 4);<br /><br />ints.Add(0);<br /><br /><span style="COLOR: blue">foreach</span> (<span style="COLOR: blue">int</span> i <span style="COLOR: blue">in</span> result) {<br /><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: #2b91af">Console</span>.WriteLine(i);<br />}</span></p>
<p>Without the yield you'd get the numbers 3 through 1 since you added 0 after the call to MyWhere(). But since the yield in MyWhere() (and the Where() in System.Linq) defers execution until the foreach statement, you actually get 3 through 0. Ready for a little more mind bending? How about this:</p>
<p><span style="FONT-SIZE: 10pt; COLOR: #2b91af; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">IList</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA; mso-no-proof: yes">&lt;<span style="COLOR: blue">int</span>&gt; ints = <span style="COLOR: blue">new</span> <span style="COLOR: #2b91af">List</span>&lt;<span style="COLOR: blue">int</span>&gt;() {9,8,7,6,5,4,3,2,1};<br /><br /><span style="COLOR: blue">int</span> j = 4;<br /><br /><span style="COLOR: #2b91af">IEnumerable</span>&lt;<span style="COLOR: blue">int</span>&gt; result = ints.MyWhere&lt;<span style="COLOR: blue">int</span>&gt;(i =&gt; i &lt; j);<br /><br />ints.Add(0);<br />j = 3;<br /><br /><span style="COLOR: blue">foreach</span> (<span style="COLOR: blue">int</span> i <span style="COLOR: blue">in</span> result) {<br /><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="COLOR: #2b91af">Console</span>.WriteLine(i);<br />}</span></p>
<p>Does the state of j get captured? My intuition would say yes. If so you'd expect 3 through 0. Well, the closure part of anonymous methods and lambdas work by keeping a reference to their calling object (this). So consequently they always get the most up to date value of a variable. So if your intuition works like mine you'd be wrong. You actually get the numbers 2 through 0. Crazy huh? And definitely something I hope I won't run into in someone's code (<a href="http://www.jetbrains.com/resharper/">JetBrains ReSharper</a> actually warns you if you do something crazy like this).</p>
<p><b>Conclusion</b></p>
<p>If this made sense then you should have a pretty solid grasp of how most of Linq to Objects works. Understanding extension methods, Func delegates, and yield statements should form the majority of what Linq does. Well, except for expression trees. But that's a topic for another post. Please post if this doesn't make sense or if I got it all wrong, I'd love to hear from you.</p><br />
<p>P.S. To comment on this article please use <a href="http://rapidapplicationdevelopment.blogspot.com/2008/03/how-systemlinqwhere-really-works.html">my public Blog</a>.</p> 
